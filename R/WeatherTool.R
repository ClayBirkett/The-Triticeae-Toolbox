####################################################################################################################
####################################### Historical Weather Data Tool for T3 ########################################
####################################################################################################################

###Make a button the User could push to select the next closest weather station from 'SortByDist'.  This would be for the event where the User does not like the current station/is suspicious of the data from the current station/wants to validate with a second set of readings.

###Should really be able to click the button more than once.  Can we count how many times a User clicks???  The click number would equal "c".

###Everytime the USER clicks "Next" it should quickly rerun the JS script and write a text file.  Then the R script is rerun to completion with the new text file (which redefines "c") from JS.

###Previous button

###This would work in the same way. Behind this button would be a quick JS script to count clicks, but the count would be by "-1" everytime the button is clicked.  Need to make it so that the count can never go below "1".  Then rerun this script.

###Install 'weatherData' R package from Github, if this has not been done on your machine yet.
#install.packages("devtools")
#library("devtools")
#install_github("Ram-N/weatherData")

### These libraries also require the pre-loaded packages: "DBI", "assertthat", "lazyeval", "sp", and "testthat".  Make sure these are installed in your version of R.

library(weatherData)
#library(DBI)
#library(assertthat)
#library(lazyeval)
#library(sp)
library(geosphere)
library(rwunderground)
#library(testthat)

set_api_key("10b37b4ff3f45891")

###User defined.  The User should enter their desired coordinates.  They should be entered into a field on the T3 page without any spaces or quotation marks.
#lat <- 45
#long <- -90

###The User defines their desired range of dates. Needs to be entered in the format "yyyy-mm-dd"  Quotation marks are required to avoid treating this as an equation (year minus month minus day).  Quotation marks are also the required format for CheckSummarizedDataAvailability and GetWeatherForDate functions; hopefully this does not inconvience the User too much.
#Srtdate <- "2016-02-02"
#Enddate <- "2016-07-02"

###The button runs a click counter and then writes a text file.  That text file is imported into this script.  Need to have a way to default to "1" if the button has not been pushed.  Perhaps when going to this tool page either generate or have already stored a simple tab delimited text file with the number "1" in it (This would be our default).  If the "Next" button is pushed then this file can be over written with a new file generated by a JS click counter?  Everytime after this that the "Next" or "Previous" button is pushed this small text file is over written.

##Activate when ready to go
#c <- read.table("CLICK_COUNT_FROM_JS.txt", sep="/", header=FALSE, stringsAsFactors=FALSE, check.names=FALSE)

###Manually enter "c" for testing right now
#c <- 1

###Create object with lat and long in correct format for the the geolookup function
lat_long <- paste(lat, long, sep=",")

##Location can be set by numerous different identifiers, including: Zip, Lat/Long, Name.  We want to use a specific Lat/Long to get as close as possible to the desired location.
##location <- set_location(zip_code = "14850")
location <- set_location(lat_long = lat_long)
geo <- as.data.frame(geolookup(location=location, key = get_api_key()), stringsAsFactors=FALSE)

##Calculate the distance of each weather station from the Users location in MILES.  1 Mile = 1609.344 Meters
n <- nrow(geo)
dist <- as.data.frame(matrix(nrow = n, ncol= 0))
for (i in 1:n) {
  distance <- distCosine(c(long, lat), c(geo[i,7], geo[i,6]))/1609.344
  distance <- round(distance, digits=2)
  newline <- data.frame(distance)
  dist <- rbind(dist, newline)
}

###Bind this dataset to the original dataset
Combined <- cbind(geo, dist)

###Check to see if data is available during the dates selected for each station.  Data available = 1; Data not available = 0.
nairport <- sum(Combined$type == "airport")
npws <- nrow(Combined)-nairport
AirDataOK <- as.data.frame(matrix(nrow = nairport, ncol= 0))

###Want to use "checkSummarizedDataAvailability" function for the airports here but the function throws errors for older dates.  Thsi still works but is not ideal.
for (i in 1:nairport) {
	Data_Available<- checkDataAvailabilityForDateRange(Combined[i,5], Srtdate, Enddate, station_type = 'airportCode')
	newline <- data.frame(Data_Available)
	AirDataOK <-rbind(AirDataOK, newline)
  	}
  	
if (npws >= 1){

PWSDataOK <- as.data.frame(matrix(nrow = npws, ncol= 0))
for (i in 1:npws) {
	Data_Available<- checkSummarizedDataAvailability(Combined[4+i,5], Srtdate, Enddate, station_type = 'ID')	
	newline <- data.frame(Data_Available)
	PWSDataOK <-rbind(PWSDataOK, newline)
  	}

OKDataToCombine <- rbind(AirDataOK, PWSDataOK)
}else{
	OKDataToCombine <- AirDataOK
	}

###Bind this available data dataset to the original dataset
HelloData <- cbind(Combined, OKDataToCombine)

###Sort function to sort first by data availability and then by distance (miles), row 1 is the closest station with data
SortByDist <- HelloData[order(-HelloData$Data_Available, HelloData$distance),]

#########################################################################################################################
#########################################################################################################################

###Retrieve the data

###Limit to only looking for data from stations we have already identified as having data for the specified dates
nWithData <- sum(SortByDist$Data_Available == 1)

if (c <= nWithData) {

###Is the closest station an airport?
isAirport <- (SortByDist[c,1] == "airport")

if (isAirport){
##This works if airport is closest
Data<-getWeatherForDate(SortByDist[c,5], Srtdate, Enddate, opt_detailed=FALSE, opt_verbose=FALSE, opt_temperature_columns=FALSE, opt_custom_columns=TRUE, custom_columns= c(2, 3, 4, 9, 20, 21, 22))
}
else{
##This works if pws is closest
Data<-getWeatherForDate(SortByDist[c,5], Srtdate, Enddate, station_type="ID", opt_detailed=FALSE, opt_verbose=FALSE, opt_temperature_columns=FALSE, opt_custom_columns=TRUE, custom_columns= c(2, 3, 4, 9, 16))
}
}

DataExists <- exists("Data")

if (DataExists == TRUE){
	isNoData <- length(Data) < 1
	if (isNoData == FALSE){

#########################################################################################################################
#########################################################################################################################

###Airport Precipitation can be non-numeric, i.e. "T" for trace.  Set all "T" readings to "0".  Pretty close approximation since "trace" is too small to get an actual measurement.	

AirportPrecipExists <- any(names(Data) == "PrecipitationIn")

if (AirportPrecipExists == TRUE) {
Data$PrecipitationIn <- ifelse(Data[,6]=="T", 0, Data[,6])
###Make sure Data$Precipitation is a number
Data$PrecipitationIn <- as.numeric(Data$PrecipitationIn)

} else{
colnames(Data) <- c("Date", "Max_TemperatureF", "Mean_TemperatureF", "Min_TemperatureF", "Mean_Humidity", "PrecipitationIn")
}

###A little data quality check.  Difficult for us to clean up data when the script needs to be able to handle a wide range of data (diverse locations), but this should remove any clearly questionable data points from a malfunctioning weather station.

Data = Data[140 > Data$Max_TemperatureF & Data$Max_TemperatureF > -60 & Data$PrecipitationIn < 8, ]

#########################################################################################################################
#########################################################################################################################

###We are going to want some data on the weather station itself. 

Station <- data.frame(SortByDist[c,5], SortByDist[c,2], SortByDist[c,3], SortByDist[c,6], SortByDist[c,7], SortByDist[c,9], SortByDist[c,1])

colnames(Station) <- c("Station ID", "City", "State", "Latitude", "Longitude", "Distance From Location (Miles)", "Station Type")
	
#########################################################################################################################
#########################################################################################################################

###Now have data in data frames -- lets display a table of the data!

#Write text file of station data to be displayed as a one line table directly prior to the weather data on T3.
write.table(Station, "StationInfo.txt", sep="\t", row.names=FALSE, quote=FALSE)

#Write text file of weather data to be displayed as a table on T3.
write.table(Data, "WeatherData.txt", sep="\t", row.names=FALSE, quote=FALSE)

#########################################################################################################################
#########################################################################################################################

###Let's make some graphs!
library(lattice)

###Calculate y-axis limits for TempGraph
ymax <- max(Data$Max_TemperatureF)+5
ymin <- min(Data$Min_TemperatureF)-5
ylim <- range(ymax, ymin)

###Calculate y-axis limits for PrecipGraph
ymax2 <- max(Data$Precipitation)+0.1
ymin2 <- min(Data$PrecipitationIn)-0.01
ylim2 <- range(ymax2, ymin2)

###Number of days with data
n2 <-nrow(Data)

###Will use this for the number of intervals on x-axis.  (Should be one less than total number of dates) Using this to correct for incorrect lable spacing that appears to occur when data from 4 or less days is used.
tick <-(nrow(Data))-1

###Convert dates to PosIXct format from POSIXlt format.
Data$Date <- as.POSIXct(Data$Date)

if(n2<=4) {

TempGraph <- xyplot(Max_TemperatureF + Mean_TemperatureF + Min_TemperatureF ~ Date, data=Data, scales=list("free", tck=c(1,0), cex=1.3, x=list(tick.number=tick)), ylim=ylim, typ='l', lwd=3, grid=TRUE, auto.key=list(space="top", text=c("High (F)", "Mean (F)", "Low (F)"), columns=3, points=FALSE, col=c(2, 1, 4)), main=list("Temperature for Selected Range", cex=1.7), ylab=list("Degrees F", cex=1.5), xlab=list("Date", cex=1.5), col= c(2,1,4))

PrecipGraph <- xyplot(PrecipitationIn ~ Date, data=Data, scales=list("free", tck=c(1,0), cex=1.3, x=list(tick.number=tick)), typ='l', lwd=3, grid=TRUE, auto.key=list(text=c("Precipitation"), points=FALSE, col=c(4)), ylim=ylim2, main=list("Precipitation for Selected Range", cex=1.7), ylab=list("Inches", cex=1.5), xlab=list("Date", cex=1.5), col= c(4))

} else{
TempGraph <- xyplot(Max_TemperatureF + Mean_TemperatureF + Min_TemperatureF ~ Date, data=Data, scales=list("free", tck=c(1,0), cex=1.3), ylim=ylim, typ='l', lwd=3, grid=TRUE, auto.key=list(space="top", text=c("High (F)", "Mean (F)", "Low (F)"), columns=3, points=FALSE, col=c(2, 1, 4)), main=list("Temperature for Selected Range", cex=1.7), ylab=list("Degrees F", cex=1.5), xlab=list("Date", cex=1.5), col= c(2,1,4))

PrecipGraph <- xyplot(PrecipitationIn ~ Date, data=Data, scales=list("free", tck=c(1,0), cex=1.3), typ='l', lwd=3, grid=TRUE, auto.key=list(text=c("Precipitation"), points=FALSE, col=c(4)), ylim=ylim2, main=list("Precipitation for Selected Range", cex=1.7), ylab=list("Inches", cex=1.5), xlab=list("Date", cex=1.5), col= c(4))
}
png(filename = "TempGraph.png", width = 800, height = 400, units = "px", res = 80, pointsize = 12)

print(TempGraph)

dev.off()

png(filename = "PrecipGraph.png", width = 800, height = 400, units = "px", res = 80, pointsize = 12)

print(PrecipGraph)

dev.off()

}
}else{
#### Writing a simple message as output to let Clay know there is no data available.
Message <- "There are no remaining weather stations in the vicinity of this location with data available for these dates"
write(Message, file="WeatherData.txt")
}		

#########################################################################################################################
#########################################################################################################################
####################################################### END #############################################################
#########################################################################################################################
#########################################################################################################################

#### This is just for reference to see which data cateogories are available for selection.  I chose the ones that I thought would be of most interest to plant researchers, but others are available if desired.


###This works if airport is closest
###dat<-getWeatherForDate("KMDZ", "2014-02-02", "2014-02-05", opt_detailed=FALSE, opt_verbose=FALSE, opt_temperature_columns=FALSE, opt_custom_columns=TRUE, custom_columns= c(2, 3, 4, 9, 20, 21, 22))

#The following columns are available:
# [1] "Date"                       "Max_TemperatureF"          "Mean_TemperatureF"         "Min_TemperatureF"          #"Max_Dew_PointF"            "MeanDew_PointF"            "Min_DewpointF"            
 #[8] "Max_Humidity"              "Mean_Humidity"             "Min_Humidity"              "Max_Sea_Level_PressureIn"  #"Mean_Sea_Level_PressureIn" "Min_Sea_Level_PressureIn"  "Max_VisibilityMiles"      
#[15] "Mean_VisibilityMiles"      "Min_VisibilityMiles"       "Max_Wind_SpeedMPH"         "Mean_Wind_SpeedMPH"        #"Max_Gust_SpeedMPH"         "PrecipitationIn"           "CloudCover"               
#[22] "Events"                    "WindDirDegrees"  


###This works if pws is closest
###dat<-getWeatherForDate("KWIATHEN2", "2014-02-02", "2014-02-05", station_type="ID", opt_detailed=FALSE, opt_verbose=FALSE, opt_temperature_columns=FALSE, opt_custom_columns=TRUE, custom_columns= c(2, 3, 4, 9, 16))

#The following columns are available:
# [1] "Date"               "TemperatureHighF"   "TemperatureAvgF"    "TemperatureLowF"    "DewpointHighF"      "DewpointAvgF"       #"DewpointLowF"       "HumidityHigh"       "HumidityAvg"        "HumidityLow"       
#[11] "PressureMaxIn"      "PressureMinIn"      "WindSpeedMaxMPH"    "WindSpeedAvgMPH"    "GustSpeedMaxMPH"    #"PrecipitationSumIn"




